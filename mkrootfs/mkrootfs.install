#!/bin/bash
#
# mkrootfs.install
#

declare -r __DEBUG__=1

set -e
set -o pipefail
set -u
# set -x

umask 0022

declare -r SCRIPT_NAME="$(basename "$0")"
declare -r SCRIPT_PATH="$(realpath --no-symlinks "$0")"
declare -r SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
declare -ar SCRIPT_INVOCATION=("$@")

################################################################################

### bash utils
. "$SCRIPT_DIR"/lib/log.sh
. "$SCRIPT_DIR"/lib/utils.sh

### options and arguments
arg_platform="pc"
arg_device="loop"
arg_rootfs_type="btrfs"
arg_suite="jammy"
arg_rootfs_tarball=""

################################################################################

usage() {
    cat << EOF

Usage:
    $SCRIPT_NAME -h | --help
    $SCRIPT_NAME [-p <platform>] [-f <rootfs-type>] [-s <suite>] [-d <device>] -t <rootfs-tarball>

    -h, --help                      print this help message and exit
    -p, --platform <platform>       set platform (default: pc)
                                    supported platforms: pc, liveos, rpi

    -f, --rootfs-type <type>        set rootfs type (default: ext4)
                                    supported types: ext4, btrfs
                                    if platform is liveos or rpi, only ext4 is supported, -f will be ignored

    -s, --suite <suite>             set suite to install (default: jammy)
                                    supported suites: jammy, noble, questing, bookworm, trixie, kzl

    -d, --device <device>           set device to install to (default: loop)

    -t, --rootfs-tarball <file>     set rootfs tarball

EOF
}

while (( $# > 0 )); do
    case "$1" in
    -h | --help)
        usage
        exit
        ;;
    -p | --platform)
        shift
        arg_platform="$1"
        ;;
    -d | --device)
        shift
        arg_device="$1"
        ;;
    -f | --rootfs-type)
        shift
        arg_rootfs_type="$1"
        ;;
    -s | --suite)
        shift
        arg_suite="$1"
        ;;
    -t | --rootfs-tarball)
        shift
        arg_rootfs_tarball="$1"
        ;;
    esac
    shift
done
readonly arg_platform
readonly arg_device
readonly arg_rootfs_type
readonly arg_suite
readonly arg_rootfs_tarball

### checks
check_root

case "$arg_rootfs_type" in
    ext4|btrfs)
        ;;
    *)
        error "Unsupported filesystem type \"$arg_rootfs_type\"" 128
        ;;
esac

case "$arg_platform" in
    pc)
        install_lib="install.pc.sh"
        img_size=8192
        rootfs_type="$arg_rootfs_type"
        ;;
    liveos)
        install_lib="install.liveos.sh"
        img_size=2560
        ;;
    rpi)
        install_lib="install.rpi.sh"
        img_size=1536
        ;;
    *)
        error "Unknown platform \"$arg_platform\"" 128
        ;;
esac
readonly install_lib
readonly img_size
readonly rootfs_type

if [[ "$arg_device" != "loop"  && ! -b "$arg_device" ]]; then
    error "$arg_device is not a valid block device to install" 128
fi

case "$arg_suite" in
    jammy|noble|questing)
        distro="ubuntu"
        ;;
    bookworm|trixie)
        distro="debian"
        ;;
    kzl)
        distro="kzl-linux"
        error "Not implemented yet" 128
        ;;
    *)
        error "Unsupported suite \"$arg_suite\"" 128
        ;;
esac
readonly distro

if [[ "$arg_platform" == "liveos" && "$distro" != "ubuntu" ]]; then
    error "${distro^} LiveOS has not been implemented yet" 128
fi

if [[ ! -f "$arg_rootfs_tarball" ]]; then
    error "Rootfs tarball \"$arg_rootfs_tarball\" does not exist or is not specified" 128
fi

################################################################################

### constants and variables (after argument processing)
declare -r TIMESTAMP="$(date +%Y%m%d_%H%M%S)"

declare -r WORK_DIR="/tmp/mkrootfs_install_$TIMESTAMP"
declare -r ROOTFS_DIR="$WORK_DIR/rootfs"
declare -r LOG_DIR="$WORK_DIR/log"

declare -r CONFIG_DIR="$SCRIPT_DIR/config"
declare -r PKGLIST_DIR="$SCRIPT_DIR/pkglist"

declare -r IMG_FILE_NAME="installed-rootfs-$arg_platform-$arg_suite-$TIMESTAMP.img"
declare -r IMG_FILE="$WORK_DIR/$IMG_FILE_NAME"
declare -r INSTALLED_DEB_PKGLIST_FILE="$PKGLIST_DIR/$arg_platform-$arg_suite-deb-pkgs.txt"
declare -r INSTALLED_PACMAN_PKGLIST_FILE="$PKGLIST_DIR/$arg_platform-$arg_suite-pacman-pkgs.txt"

declare -r UBUNTU_MIRROR="http://us.archive.ubuntu.com/ubuntu/"
# UBUNTU_MIRROR="https://mirror.arizona.edu/ubuntu/"
declare -r MOUNT_OPT="rw,noatime"

loop_device=""

### libraries
. "$SCRIPT_DIR/lib/$install_lib"
. "$SCRIPT_DIR/lib/loop.sh"
. "$SCRIPT_DIR/lib/deb.sh"
. "$SCRIPT_DIR/lib/pacman.sh"

### functions
cleanup() {
    local _signal="${1:-}"
    set +e

    sync

    log_magenta "Cleaning up..."
    cleanup_platform_specific
    loop_teardown "$loop_device"

    local _answer
    read -r -t 60 -p "Do you want to remove the working directory $WORK_DIR? [y/N] " _answer
    if [[ "$_answer" =~ ^[Yy]$ ]]; then
        rm -rf --one-file-system -- "$WORK_DIR"
    fi

    log_magenta "Done"

    trap - EXIT
    case "$_signal" in
    SIGINT)
        error "Interrupted by user" 1
        ;;
    SIGTERM)
        error "Terminated by signal" 1
        ;;
    esac

}
trap 'cleanup EXIT' EXIT
trap 'cleanup SIGINT' SIGINT
trap 'cleanup SIGTERM' SIGTERM

make_work_dirs() {
    info "Making working directory: $WORK_DIR"
    mkdir -- "$WORK_DIR"
    mkdir -- "$ROOTFS_DIR"
    mkdir -- "$LOG_DIR"
    if [[ ! -d "$PKGLIST_DIR" ]]; then
        mkdir -- "$PKGLIST_DIR"
        chown ${SUDO_UID:-0}:${SUDO_GID:-0} -- "$PKGLIST_DIR"
    fi
}

setup_loopdev() {
    info "Setting up loop device for installation on PC..."
    if [[ "$arg_device" == "loop" ]]; then
        fallocate -l "${img_size}MiB" "$IMG_FILE"
    fi
    loop_device="$(loop_get_device)"
    readonly loop_device
    if [[ -z "$loop_device" ]]; then
        error "No unused loop device found" 2
    fi
    debug "loop device: $loop_device"
    if [[ "$arg_device" == "loop" ]]; then
        loop_partitioned_setup "$loop_device" "$IMG_FILE"
    else
        loop_partitioned_setup "$loop_device" "$arg_device"
    fi
}

extract_rootfs_tarball() {
    info "Extracting root filesystem tarball: $arg_rootfs_tarball"
    tar --zstd \
        --xattrs --acls \
        --numeric-owner \
        -xpf "$arg_rootfs_tarball" \
        -C "$ROOTFS_DIR"
}

install_deb_pkgs() {
    if [[ -z "$deb_pkgs" ]]; then
        info "No deb packages to install"
        return
    fi

    sudo -u "${SUDO_USER:-root}" touch -- "$INSTALLED_DEB_PKGLIST_FILE"

    info "Installing deb packages..."
    deb_apt_install "$ROOTFS_DIR" deb_pkgs >> "$LOG_DIR/${FUNCNAME[0]}.log"
    deb_get_installed_pkgs "$ROOTFS_DIR" | sed -e '/^linux-image-.+/d' -e '/^linux-modules-.+/d' -e 's/:amd64//g' > "$INSTALLED_DEB_PKGLIST_FILE"
}

install_pacman_pkgs() {
    if [[ -z "$pacman_pkgs" ]]; then
        info "No pacman packages to install"
        return
    fi

    sudo -u "${SUDO_USER:-root}" touch -- "$INSTALLED_PACMAN_PKGLIST_FILE"

    info "Installing pacman packages..."
    pacman_bootstrap "$ROOTFS_DIR" pacman_pkgs > "$LOG_DIR/${FUNCNAME[0]}.log"
    pacman_get_installed_pkgs "$ROOTFS_DIR" > "$INSTALLED_PACMAN_PKGLIST_FILE"
}

configure_rootfs_common() {
    info "Configuring rootfs..."
    # hostname
    if [[ -n "${HOSTNAME:-}" ]]; then
        echo "$HOSTNAME" > "$ROOTFS_DIR/etc/hostname"
    else
        local _hostname
        read -r -p 'hostname: ' _hostname
        echo "$_hostname" > "$ROOTFS_DIR/etc/hostname"
    fi
    # environment
    if [[ "$distro" == "ubuntu" || "$distro" == "debian" ]]; then
        echo "PATH=\"/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/opt/bin:/opt/sbin\"" > "$ROOTFS_DIR/etc/environment"
    fi
    # passwd
    sed -i '/^root/s|/bin/bash|/bin/zsh|' "$ROOTFS_DIR"/etc/passwd
    # network
    cp -vf -- "$CONFIG_DIR/network/ethernet.network" "$ROOTFS_DIR/etc/systemd/network/ethernet.network"
    cp -vf -- "$CONFIG_DIR/network/wifi.network" "$ROOTFS_DIR/etc/systemd/network/wifi.network"
    cp -vf -- "$CONFIG_DIR/network/wpa_supplicant.conf" "$ROOTFS_DIR/etc/wpa_supplicant/wpa_supplicant.conf"
    local _wl_dev=$(ip -o link show | awk -F': ' '{print $2}' | grep 'wl.*')
    if [[ -n "$_wl_dev" ]]; then
        ln -sf wpa_supplicant.conf "$ROOTFS_DIR/etc/wpa_supplicant/wpa_supplicant-$_wl_dev.conf"
    fi
    # grml-zsh-config for root
    wget -qO "$ROOTFS_DIR/root/.zshrc" https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc
    echo '. /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh' >> "$ROOTFS_DIR/root/.zshrc"
    echo '. /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh' >> "$ROOTFS_DIR/root/.zshrc"
}

################################################################################

prologue

make_work_dirs
echo "${SCRIPT_INVOCATION[@]}" > "$LOG_DIR/command.log"
touch -- "$WORK_DIR/$arg_platform"

setup_loopdev
prepare_rootfs
extract_rootfs_tarball
if declare -F 'post_bootstrap_rootfs' > '/dev/null'; then
    info "Running post-bootstrap hook..."
    post_bootstrap_rootfs
fi

if [[ "$distro" != "kzl-linux" ]]; then
    install_deb_pkgs
fi
install_pacman_pkgs
if declare -F 'post_install_pkgs' > '/dev/null'; then
    info "Running post-install hook..."
    post_install_pkgs
fi

configure_rootfs_common
configure_rootfs_platform_specific
if declare -F 'post_configure_rootfs' > '/dev/null'; then
    info "Running post-configuration hook..."
    post_configure_rootfs
fi

if [[ "$arg_device" == "loop" ]]; then
    mv -v -- "$IMG_FILE" "$SCRIPT_DIR/images/$IMG_FILE_NAME"
    chown ${SUDO_UID:-0}:${SUDO_GID:-0} -- "$SCRIPT_DIR/images/$IMG_FILE_NAME"
    log_cyan "Successfully installed ${distro^} ${arg_suite^} on $SCRIPT_DIR/images/$IMG_FILE_NAME"
else
    log_cyan "Successfully installed ${distro^} ${arg_suite^} on $ROOTFS_DIR"
fi

cleanup
epilogue

### error codes
# 1: general error
# 2: mount error
# 127: command not found
# 128: unknown option or invalid argument
